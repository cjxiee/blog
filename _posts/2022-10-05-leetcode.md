###


###


###


###


### Day4
  链表与指针的实现
  双指针解决链表问题
    
    21. 合并两个有序链表 
    19. 删除链表的倒数第 N 个结点
    86. 分隔链表  双指针 在合并之前需要清理pointer 2 末端的next 避免成环
    876. 链表的中间结点 双指针 fast快一步
    141. 环形链表 从dummy开始 iterate
    23. 合并K个升序链表 用 heapq 把list里的node存进去， 然后每次pop出最小值，然后把对应node的next存入 queue，所以 queue里面需要存入node在list里对应的index。

### Day5
  滑动窗口
  
    /* 滑动窗口算法框架 */
    void slidingWindow(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0; 
        while (right < s.size()) {
            char c = s[right];
            // 右移（增大）窗口
            right++;
            // 进行窗口内数据的一系列更新

            while (window needs shrink) {
                char d = s[left];
                // 左移（缩小）窗口
                left++;
                // 进行窗口内数据的一系列更新
            }
        }
    }


### Day6
#### 数组双指针问题
  
  leetcode704 左右指针进行二分  leetcode34 左右边界
     
     二分模版 注意区间 还有返回值的判断
    int binarySearch(int[] nums, int target) {
        int left = 0, right = ...;

        while(...) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                ...
            } else if (nums[mid] < target) {
                left = ...
            } else if (nums[mid] > target) {
                right = ...
            }
        }
        return ...;
    }
      
      
  leetcode5 回文判断 分奇偶 从中间开始判断
  
  leetcode167 两数之和 左右指针 判断大小 缩小左右边界
  
### Day7
#### 前缀和
      
      303. 区域和检索 - 数组不可变
      304. 二维区域和检索 - 矩阵不可变
#### 差分数组   
      维护一个 差分数组 
      在区间上加减 只需操作对应的index即可
      通过当前值加上前值来还愿数组
      
      
### Day8
#### 二分查找的应用
    遇到单调函数，求左右边界是可以使用
    注意如何转化提议很重要
    
    1011. 在 D 天内送达包裹的能力 一个数组 求最小用多大的容器能 能在规定容器个数内实现
    410. 分割数组的最大值 一个数组 规定了容器个数 求最小的容器容量容纳这些数
    875. 爱吃香蕉的珂珂 同理 一个数组 规定了时间 求每个小时最少吃多少能在规定时间内完成

            if (nums[mid] == target) {r护额
            if (nums[mid] == target) {

### Day8
#### 二叉堆 （优先级队列） 多链表排序， 寻找最值
    
    ***第一类，排序合并***
    23. 合并 K 个升序链表   链表中的值加入优先级队列 重新链接
    373. 查找和最小的 K 对数字  虽然是两个组数进行数对排序 但可以抽象成多个链表排序的问题  如 以第一个数组的值为第一个值的多条链表。 ***
    378. 有序矩阵中第 K 小的元素 同上
    313. 超级丑数.  维护prime的链表 和丑数的链表， （ugly[index] *prime, prime, index+1) 每次pop出一个最小值 然后把对应链表prime上的下一个 丑数值添加入heapq
    
<img width="704" alt="image" src="https://user-images.githubusercontent.com/89954165/195712845-6450b1fd-8b63-461f-910f-1fdf86622e12.png">

    ***再来看第二类，寻找第 k 个最大元素这类题：***
    215. 数组中的第 K 个最大元素 维护一个size 为k的最小二叉堆 最后会留下k个最大值
    
    451. 根据字符出现频率排序 字典排序 提取key 对key进行排序 
      list(freq.keys()).sort(key = lambda x: -freq[x]) #根据value对key进行降序排列
    703. 数据流中的第 K 大元素
    295. 数据流的中位数 大小顶堆 前一半数据在大顶堆里，
      

### Day9
#### 二叉树    遍历or递归 与子树相关后序遍历 
**二叉树的前中后序**
<img width="1041" alt="image" src="https://user-images.githubusercontent.com/89954165/195912687-c556797d-ffa6-4e90-8e0f-3a84d234a97b.png">
**解法**
二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 回溯算法核心框架 和 动态规划核心框架。




#### dp

  1. 重叠子问题
  2. 状态转移方程
  3. 最优子结构
  
  套路
  1.明确 状态
  2.明确 选择   应用递归进行选择
  3.明确 dp函数
  4.明确 base case

  <img width="937" alt="image" src="https://user-images.githubusercontent.com/89954165/195922746-2c8bbf02-5d9a-422b-b59a-fd51c13f51a9.png">


#### 回溯算法
    穷举
    
    res = []
    def backtrack(self, track, list):
      if (end condition):
        res.add(track)
        return
      for i in list:
        # make decision

        backtrack(track, list)
        # undo decision
      
    
### Day10
#### NIO 笔试
    
    矩阵转至 暴力解 两个for loop
    牛牛函数 求二进制下最小的1 x & -x
    
#### ROBOTSENSE 笔试
    
    堆箱子 dp问题    对箱子排序 dp[i] --i对应每个箱子   两个for loop 用于更新 i箱子可以堆的最大高度
    
#### 栈
    
     143. 重排链表
     20. 有效的括号  遇到有括号 一个元素出栈 用一个dict来维护对应的pair
     150. 逆波兰表达式求值 运算符 从stack中pop两个值出来 根据符号进行运算
     
  ##### 单调栈
  
      从数组尾部开始便利 用stack保存一个单调的数组 通过维护这个数组来寻找更大 更小值
      739. 每日温度   496. 下一个更大元素 I    两题思路一致 一个存 index 一个存值
      
### Day11
##### 单调栈
    
    1944. 队列中可以看到的人数    单调栈模版调用， 如果有比i高的人 计数器需要加1
    1475. 商品折扣后的最终价格  same
    
    402. 移掉 K 位数字 从做往右找一个单调性  如果头部为0 则不加入
  
  
### Day12
##### 单调队列 解决滑动窗口最大值问题
    
    239. 滑动窗口最大值    collection.deque 用双端队列维护一个单调减的队列， 如果加入值比前值大，则将前值压出 窗口最大为3 每次到三个值时 压出先进的元素
    1438. 绝对差不超过限制的最长连续子数组    SortedList
    

  
### Day13
##### 

    862. 和至少为 K 的最短子数组   前缀和 单调队列 滑动窗口
    **918. 环形子数组的最大和**  在数组尾部拷贝一份形成环形数组 前缀和 用一个数不可用两次所以 用一个单调队列存可行的presum 长度为数组的大小 通过preSum - s.min来update最大和
    1696. 跳跃游戏 VI  动态规划 加上 通过单调队列来优化      similar problem   1425. 带限制的子序列和    209. 长度最小的子数组 🟠
    
    hash
    拉链法原理 一个table 每个index为一个slot slot用于存储链表
    线性探查法 一个table 存key，value pair， 通过hashfunc将key映射到index， 如果index被占据，向后探查找到空位存放
    
    
### Day14
#####哈希表的应用     
    
    15. 三数之和 🟠   以2sum为基础 进行穷举 注意跳过重复元素
    138. 复制带随机指针的链表 先克隆新节点 再链接
    242. 有效的字母异位词. 判断长度， 哈希表计数， python可以用counter来做
    49. 字母异位词分组     用defaultdict（list）便于储存需要返回的str结果   group = collections.defaultdict(list)
    169. 多数元素
    387. 字符串中的第一个唯一字符
    389. 找不同  位运算，ord() cast to ascil  chr() cast to char https://leetcode.cn/problems/find-the-difference/solutions/526048/python3-si-chong-jie-fa-ha-xi-biao-shu-z-19mi/
    442. 数组中重复的数据 哈希原地标记 用正负号来标记 如果已标为负 则出现过了
    448. 找到所有数组中消失的数字 同上^^
    4. 寻找两个正序数组的中位数 大小堆。sol2： 二分查找
    
### Day15
#####哈希表的应用   

      linkedhashmap  map key to node, use list connect ndoe   有序
      Arrayhashmap   map key to index, key-value pair is stored in the array
      
      32. 最长有效括号 需要一个 dp 数组，记录 leftIndex 相邻合法括号子串的长度，才能得出题目想要的正确结果。
    
    
### Day16

      1235. 规划兼职工作    dp + 二分查找 dp记录前i份工作的最大收益
#####经典数据结构设计题      
      146. LRU 缓存     由于我们要同时维护一个双链表 cache (维护顺序)和一个哈希表 map（维护 key 映射 node）
      895. 最大频率栈    map val2freq map freq to a stack fo list w.r.t this freq
      284. 顶端迭代器    设一个flag 来判断 是否调用peek（） 如果是的说明指针已经移动了
    

### Day17
##### BFS


          // 计算从起点 start 到终点 target 的最近距离
    int BFS(Node start, Node target) {
        Queue<Node> q; // 核心数据结构
        Set<Node> visited; // 避免走回头路

        q.offer(start); // 将起点加入队列
        visited.add(start);
        int step = 0; // 记录扩散的步数

        while (q not empty) {
            int sz = q.size();
            /* 将当前队列中的所有节点向四周扩散 */
            for (int i = 0; i < sz; i++) {
                Node cur = q.poll();
                /* 划重点：这里判断是否到达终点 */
                if (cur is target)
                    return step;
                /* 将 cur 的相邻节点加入队列 */
                for (Node x : cur.adj()) {
                    if (x not in visited) {
                        q.offer(x);
                        visited.add(x);
                    }
                }
            }
            /* 划重点：更新步数在这里 */
            step++;
        }
    }
    
    752. 打开转盘锁  主要是写出node如何移动
    111. 二叉树的最小深度
    102. 二叉树层序遍历 
    107. 二叉树层序遍历2 res[::-1] 反转list

#### stock related problem
<img width="777" alt="image" src="https://user-images.githubusercontent.com/89954165/197364068-d6fefee7-5137-4a37-ba5f-a4719b21e181.png">

    121. 买卖股票的最佳时机
    
    122.  买卖股票的最佳时机 II
    309. 最佳买卖股票时机含冷冻期   存一个dp_0_pre 用来两天前的价格
    714. 买卖股票的最佳时机含手续费    每次买入加一个fee
——
    188. 买卖股票的最佳时机 IV
    
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        if k >= (n // 2):
            # inf times of trading
            dp_0 = 0
            dp_1 = -float("inf")
            for i in range(n):
                temp = dp_0
                dp_0 = max(dp_0, dp_1 + prices[i])
                dp_1 = max(dp_1, temp - prices[i])
            return dp_0
        else:
            # maxProfit_kTimes
            dp =[[[0,0] for _ in range(k+1)] for _ in range(n)]
            # k = 0 时的 base case
            # for (int i = 0; i < n; i++) {
            #     dp[i][0][1] = Integer.MIN_VALUE;
            #     dp[i][0][0] = 0;
            # }
            
            for i in range(n):
                for k_ in range(k,0, -1):
                    if i== 0:
                        dp[i][k_][0] = 0
                        dp[i][k_][1] = - prices[i]
                        continue
                    dp[i][k_][0] = max(dp[i-1][k_][0], dp[i-1][k_][1] + prices[i])
                    dp[i][k_][1] = max(dp[i-1][k_][1], dp[i-1][k_-1][0] - prices[i])

            return dp[-1][-1][0]


### Day18
    1768. 交替合并字符串   zip_longest的技巧  
    915. 分割数组 两次遍历， 第一次从左到右，记录前面的最大值， 从右到左，记录前面的最小值。 第二次遍历，从左向右，找边界。
    
##### house rob

    198. 打家劫舍. DP 抢或不抢 dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    213. 打家劫舍 II. 环形数组 将问题拆为两条， 抢第一个[0,n-2] rob最后一个[1,n-1] 
    337. 打家劫舍 III. 二叉树 对于一个节点 存在偷与不偷 保存对应的最大值
    
    
