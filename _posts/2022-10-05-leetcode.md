###


###


###


###


### Day4
  链表与指针的实现
  双指针解决链表问题
    
    21. 合并两个有序链表 
    19. 删除链表的倒数第 N 个结点
    86. 分隔链表  双指针 在合并之前需要清理pointer 2 末端的next 避免成环
    876. 链表的中间结点 双指针 fast快一步
    141. 环形链表 从dummy开始 iterate
    23. 合并K个升序链表 用 heapq 把list里的node存进去， 然后每次pop出最小值，然后把对应node的next存入 queue，所以 queue里面需要存入node在list里对应的index。

### Day5
  滑动窗口
  
    /* 滑动窗口算法框架 */
    void slidingWindow(string s, string t) {
        unordered_map<char, int> need, window;
        for (char c : t) need[c]++;

        int left = 0, right = 0;
        int valid = 0; 
        while (right < s.size()) {
            char c = s[right];
            // 右移（增大）窗口
            right++;
            // 进行窗口内数据的一系列更新

            while (window needs shrink) {
                char d = s[left];
                // 左移（缩小）窗口
                left++;
                // 进行窗口内数据的一系列更新
            }
        }
    }


### Day6
#### 数组双指针问题
  
  leetcode704 左右指针进行二分  leetcode34 左右边界
     
     二分模版 注意区间 还有返回值的判断
    int binarySearch(int[] nums, int target) {
        int left = 0, right = ...;

        while(...) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                ...
            } else if (nums[mid] < target) {
                left = ...
            } else if (nums[mid] > target) {
                right = ...
            }
        }
        return ...;
    }
      
      
  leetcode5 回文判断 分奇偶 从中间开始判断
  
  leetcode167 两数之和 左右指针 判断大小 缩小左右边界
  
### Day7
#### 前缀和
      
      303. 区域和检索 - 数组不可变
      304. 二维区域和检索 - 矩阵不可变
#### 差分数组   
      维护一个 差分数组 
      在区间上加减 只需操作对应的index即可
      通过当前值加上前值来还愿数组
      
      
### Day8
#### 二分查找的应用
    遇到单调函数，求左右边界是可以使用
    注意如何转化提议很重要
    
    1011. 在 D 天内送达包裹的能力 一个数组 求最小用多大的容器能 能在规定容器个数内实现
    410. 分割数组的最大值 一个数组 规定了容器个数 求最小的容器容量容纳这些数
    875. 爱吃香蕉的珂珂 同理 一个数组 规定了时间 求每个小时最少吃多少能在规定时间内完成

            if (nums[mid] == target) {r护额
            if (nums[mid] == target) {

### Day8
#### 二叉堆 （优先级队列） 多链表排序， 寻找最值
    
    ***第一类，排序合并***
    23. 合并 K 个升序链表   链表中的值加入优先级队列 重新链接
    373. 查找和最小的 K 对数字  虽然是两个组数进行数对排序 但可以抽象成多个链表排序的问题  如 以第一个数组的值为第一个值的多条链表。 ***
    378. 有序矩阵中第 K 小的元素 同上
    313. 超级丑数.  维护prime的链表 和丑数的链表， （ugly[index] *prime, prime, index+1) 每次pop出一个最小值 然后把对应链表prime上的下一个 丑数值添加入heapq
    
<img width="704" alt="image" src="https://user-images.githubusercontent.com/89954165/195712845-6450b1fd-8b63-461f-910f-1fdf86622e12.png">

    ***再来看第二类，寻找第 k 个最大元素这类题：***
    215. 数组中的第 K 个最大元素 维护一个size 为k的最小二叉堆 最后会留下k个最大值
    
    451. 根据字符出现频率排序 字典排序 提取key 对key进行排序 
      list(freq.keys()).sort(key = lambda x: -freq[x]) #根据value对key进行降序排列
    703. 数据流中的第 K 大元素
    295. 数据流的中位数 大小顶堆 前一半数据在大顶堆里，
      

### Day9
#### 二叉树    遍历or递归 与子树相关后序遍历 
**二叉树的前中后序**
<img width="1041" alt="image" src="https://user-images.githubusercontent.com/89954165/195912687-c556797d-ffa6-4e90-8e0f-3a84d234a97b.png">
**解法**
二叉树题目的递归解法可以分两类思路，第一类是遍历一遍二叉树得出答案，第二类是通过分解问题计算出答案，这两类思路分别对应着 回溯算法核心框架 和 动态规划核心框架。




#### dp

  1. 重叠子问题
  2. 状态转移方程
  3. 最优子结构
  
  套路
  1.明确 状态
  2.明确 选择   应用递归进行选择
  3.明确 dp函数
  4.明确 base case

  <img width="937" alt="image" src="https://user-images.githubusercontent.com/89954165/195922746-2c8bbf02-5d9a-422b-b59a-fd51c13f51a9.png">


#### 回溯算法
    穷举
    
    res = []
    def backtrack(self, track, list):
      if (end condition):
        res.add(track)
        return
      for i in list:
        # make decision

        backtrack(track, list)
        # undo decision
      
    
### Day10
#### NIO 笔试
    
    矩阵转至 暴力解 两个for loop
    牛牛函数 求二进制下最小的1 x & -x
    
#### ROBOTSENSE 笔试
    
    堆箱子 dp问题    对箱子排序 dp[i] --i对应每个箱子   两个for loop 用于更新 i箱子可以堆的最大高度
    
#### 栈
    
     143. 重排链表
     20. 有效的括号  遇到有括号 一个元素出栈 用一个dict来维护对应的pair
     150. 逆波兰表达式求值 运算符 从stack中pop两个值出来 根据符号进行运算
     
  ##### 单调栈
  
      从数组尾部开始便利 用stack保存一个单调的数组 通过维护这个数组来寻找更大 更小值
      739. 每日温度   496. 下一个更大元素 I    两题思路一致 一个存 index 一个存值
      
### Day11
##### 单调栈
    
    1944. 队列中可以看到的人数    单调栈模版调用， 如果有比i高的人 计数器需要加1
    1475. 商品折扣后的最终价格  same
    
    402. 移掉 K 位数字 从做往右找一个单调性  如果头部为0 则不加入
  
  
### Day12
##### 单调队列 解决滑动窗口最大值问题
    
    239. 滑动窗口最大值    collection.deque 用双端队列维护一个单调减的队列， 如果加入值比前值大，则将前值压出 窗口最大为3 每次到三个值时 压出先进的元素
    1438. 绝对差不超过限制的最长连续子数组    SortedList
    

  
### Day13
##### 

    862. 和至少为 K 的最短子数组   前缀和 单调队列 滑动窗口
    **918. 环形子数组的最大和**  在数组尾部拷贝一份形成环形数组 前缀和 用一个数不可用两次所以 用一个单调队列存可行的presum 长度为数组的大小 通过preSum - s.min来update最大和
    1696. 跳跃游戏 VI  动态规划 加上 通过单调队列来优化      similar problem   1425. 带限制的子序列和    209. 长度最小的子数组 🟠
    
    hash
    拉链法原理 一个table 每个index为一个slot slot用于存储链表
    线性探查法 一个table 存key，value pair， 通过hashfunc将key映射到index， 如果index被占据，向后探查找到空位存放
    
    
### Day14
#####哈希表的应用     
    
    15. 三数之和 🟠   以2sum为基础 进行穷举 注意跳过重复元素
    138. 复制带随机指针的链表 先克隆新节点 再链接
    242. 有效的字母异位词. 判断长度， 哈希表计数， python可以用counter来做
    49. 字母异位词分组     用defaultdict（list）便于储存需要返回的str结果   group = collections.defaultdict(list)
    169. 多数元素
    387. 字符串中的第一个唯一字符
    389. 找不同  位运算，ord() cast to ascil  chr() cast to char https://leetcode.cn/problems/find-the-difference/solutions/526048/python3-si-chong-jie-fa-ha-xi-biao-shu-z-19mi/
    442. 数组中重复的数据 哈希原地标记 用正负号来标记 如果已标为负 则出现过了
    448. 找到所有数组中消失的数字 同上^^
    4. 寻找两个正序数组的中位数 大小堆。sol2： 二分查找
    
### Day15
#####哈希表的应用   

      linkedhashmap  map key to node, use list connect ndoe   有序
      Arrayhashmap   map key to index, key-value pair is stored in the array
      
      32. 最长有效括号 需要一个 dp 数组，记录 leftIndex 相邻合法括号子串的长度，才能得出题目想要的正确结果。
    
    
### Day16

      1235. 规划兼职工作    dp + 二分查找 dp记录前i份工作的最大收益
#####经典数据结构设计题      
      146. LRU 缓存     由于我们要同时维护一个双链表 cache (维护顺序)和一个哈希表 map（维护 key 映射 node）
      895. 最大频率栈    map val2freq map freq to a stack fo list w.r.t this freq
      284. 顶端迭代器    设一个flag 来判断 是否调用peek（） 如果是的说明指针已经移动了
    

### Day17
##### BFS


          // 计算从起点 start 到终点 target 的最近距离
    int BFS(Node start, Node target) {
        Queue<Node> q; // 核心数据结构
        Set<Node> visited; // 避免走回头路

        q.offer(start); // 将起点加入队列
        visited.add(start);
        int step = 0; // 记录扩散的步数

        while (q not empty) {
            int sz = q.size();
            /* 将当前队列中的所有节点向四周扩散 */
            for (int i = 0; i < sz; i++) {
                Node cur = q.poll();
                /* 划重点：这里判断是否到达终点 */
                if (cur is target)
                    return step;
                /* 将 cur 的相邻节点加入队列 */
                for (Node x : cur.adj()) {
                    if (x not in visited) {
                        q.offer(x);
                        visited.add(x);
                    }
                }
            }
            /* 划重点：更新步数在这里 */
            step++;
        }
    }
    
    752. 打开转盘锁  主要是写出node如何移动
    111. 二叉树的最小深度
    102. 二叉树层序遍历 
    107. 二叉树层序遍历2 res[::-1] 反转list

#### stock related problem
<img width="777" alt="image" src="https://user-images.githubusercontent.com/89954165/197364068-d6fefee7-5137-4a37-ba5f-a4719b21e181.png">

    121. 买卖股票的最佳时机
    
    122.  买卖股票的最佳时机 II
    309. 最佳买卖股票时机含冷冻期   存一个dp_0_pre 用来两天前的价格
    714. 买卖股票的最佳时机含手续费    每次买入加一个fee
——
    188. 买卖股票的最佳时机 IV
    
    def maxProfit(self, k: int, prices: List[int]) -> int:
        n = len(prices)
        if k >= (n // 2):
            # inf times of trading
            dp_0 = 0
            dp_1 = -float("inf")
            for i in range(n):
                temp = dp_0
                dp_0 = max(dp_0, dp_1 + prices[i])
                dp_1 = max(dp_1, temp - prices[i])
            return dp_0
        else:
            # maxProfit_kTimes
            dp =[[[0,0] for _ in range(k+1)] for _ in range(n)]
            # k = 0 时的 base case
            # for (int i = 0; i < n; i++) {
            #     dp[i][0][1] = Integer.MIN_VALUE;
            #     dp[i][0][0] = 0;
            # }
            
            for i in range(n):
                for k_ in range(k,0, -1):
                    if i== 0:
                        dp[i][k_][0] = 0
                        dp[i][k_][1] = - prices[i]
                        continue
                    dp[i][k_][0] = max(dp[i-1][k_][0], dp[i-1][k_][1] + prices[i])
                    dp[i][k_][1] = max(dp[i-1][k_][1], dp[i-1][k_-1][0] - prices[i])

            return dp[-1][-1][0]


### Day18
    1768. 交替合并字符串   zip_longest的技巧  
    915. 分割数组 两次遍历， 第一次从左到右，记录前面的最大值， 从右到左，记录前面的最小值。 第二次遍历，从左向右，找边界。
    
##### house rob

    198. 打家劫舍. DP 抢或不抢 dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    213. 打家劫舍 II. 环形数组 将问题拆为两条， 抢第一个[0,n-2] rob最后一个[1,n-1] 
    337. 打家劫舍 III. 二叉树 对于一个节点 存在偷与不偷 保存对应的最大值
    
    
##### 递归链表

    206. 反转链表   清晰reverse()的定义， reverse函数将head.next为头的链表反转，并返回末端节点的头节点  
        head.next.next = head 将当前头部加到链表末端
        head.next = None 将当前头部的next置为空
    92. 反转链表 II   
        先实现left为1 right为任意值的反转，这个与206类似，但我们需要记一个后驱节点，将反转的尾部接到后驱节点上
        base case就是从头节点开始反转
        用递归的思想，将left不为1的情况，变化成1的情况进行处理。
      
        
### Day19
    
    934 最短的桥
    DFS BFS
        

### Day20
	
    46. 全排列 回溯 track需要用copy储存
 
 
### Day21

	单调栈搜索左右边界
	907. 子数组的最小值之和
	minstack, left, right = [], [0] * n, [0] * n
        for i in range(n):
            while minstack and arr[minstack[-1]] >= arr[i]:
                right[minstack.pop()] = i
            left[i] = minstack[-1] if minstack else -1
	    minstack.append(i)
	
	25. K 个一组翻转链表：用迭代把前k个反转，然后用返回新的头节点，后面前k个进行递归，接到上一层的尾部（即旧头节点）

	18. 四数之和 nSum and twoSum
	234. 回文链表 后续遍历作为right指针，head作为右指针，进行比较
	83. 删除排序链表中的重复元素 快慢指针



### Day22
#### 遍历二维数组
	
	48. 旋转图像 Transpose将行转为列， 在mirror（镜像）
	54. 螺旋矩阵 4个边界，遍历的同时收缩边界
	59. 螺旋矩阵 II


### Day23
#### 滑动窗口的延伸 RabinKarp
	
	**用数值替代窗口，每次从左侧加入一位，相当于将数值进一位并加上个位数的数值，删除则是减去最大位数上的数值（- R**（L-1））位数L，进制数R
	滑动窗口的套路
	取余运算，避免整形爆炸，最好是一个较大的素数

	X % Q == (X + Q) % Q
	(X + Y) % Q == (X % Q + Y % QR
	滑动窗口的套路
	取余运算，避免整形爆炸，最好是一个较大的素数
	
	常数时间删除-查找数组中的任意元素
	380. O(1) 时间插入、删除和获取随机元素 dict 和 array的组合 通过把需要删除的元素换到最后一个，进行移除，注意要将map移除
	
	田忌赛马背后的算法决策
	870. 优势洗牌 排序 双指针 如果大于就将right指针的值加入 否则left

	
	528. 按权重随机选择 改成概率 然后二分搜索leftbound

### Day24
	
	去重：字典or boolean队列 &栈。加上单调栈和计数器来判断是否需要移除前数
	316. 去除重复字母
	1081. 不同字符的最小子序列
	402. 移掉 K 位数字  单调栈，注意处理头部0和k>=length的情况

	贪心，把不满足条件的值以及之后的值都改为9，前一位-1
	738. 单调递增的数字	最后输出时，直接转为int型，会自动处理头部的0
	
	二叉树：遍历与分解问题
	116. 填充每个节点的下一个右侧节点指针  idea1： 从右向左BFS idea2: 三叉树
	<img width="789" alt="image" src="https://user-images.githubusercontent.com/89954165/198917745-b9c781ac-8633-4af6-9b93-c6508d87e953.png">

	654. 最大二叉树 找到最大值，然后左右递归
	
	
### Day25

	二叉树构造: 找到根节点，然后构造左右子树
	105.从前序与中序遍历序列构造二叉树	、定义build为构造左右子树然后返回根节点，需要找到对应左右子树的索引。
	
<img width="772" alt="image" src="https://user-images.githubusercontent.com/89954165/199084337-6c27d59f-21f8-47ae-a0fc-d374ee4fb849.png">

	106. 从中序与后序遍历序列构造二叉树 同上，找到左右子树对应的index
	889. 根据前序和后序遍历构造二叉树，左右子树，以preorder的下一个数为左节点，找到对应的左节点在postorder中的位置，（index1），找对左树的长度，算出右树头节点的位置
	297. 二叉树的序列化与反序列化 同样适用递归的方法进行反序列化
	652. 寻找重复的子树  后序遍历+序列化+set&dict进行查重， dict存入第一个重复的node.
	912. 排序数组 归并排序 左右sort 然后merge 注意merge的是已经排好序的子队列	

### Day26
#### 归并排序的应用
	
	493. 翻转对 运用了归并排序的思想，在merge过程中，我们需要比较有右边集合有多少满足条件的数，并有counter计数。通过一个end指针来维护满足条件的区间[mid+1, end]则为当前右指针满足的个数，因为集合已经排好序了，所以右指针的下一个满足个数至少为前一个指针的满足的个数
	315. 计算右侧小于当前元素的个数		不改变数组本身，而是用一个下标索引的数组，来进行排序，可以通过下标访问到需要计数的index。
	327. 区间和的个数	前缀和的归并排序，merge时记录满足条件的个数，[start,end)end为第一个不满足上界的index(前一个不满足的话，后面一个可能满足，所以要向后判断)，start为第一个满足下届的index(前面不满足的话，后面的也不可能满足，所以可以移动start index)，中间的个数为count
	# count
            start, end = mid+1, mid+1
            for i in range(lo, mid +1):
                while start<=hi and temp[start] -temp[i] < lower:
                    start +=1
                while end<=hi and temp[end] - temp[i] <= upper:
                    end +=1
                self.count += end - start

